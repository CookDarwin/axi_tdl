/**********************************************
_______________________________________ 
___________    Cook Darwin   __________    
_______________________________________
descript:
author : Cook.Darwin
Version: VERA.0.0
creaded: 2017/5/19 
madified:
***********************************************/
`timescale 1ns/1ps
module long_fifo_xbit_SL #(
    parameter LENGTH = 4096*2,
    parameter DSIZE  = 36  // 4 9 18 36 72
)(
    input               clk,
    input               rst,
    input [8:0]         din   ,
    input               wr_en ,
    input               rd_en ,
    output [8:0]        dout  ,
    output              full  ,
    output              empty
);

initial begin
    if(DSIZE != 4 && DSIZE != 9 && DSIZE != 18 && DSIZE != 36 && DSIZE != 72)begin
        $error("%s,%d,long_fifo_xbit_SL.DSIZE  must in [4 9 18 36 72]",`__FILE__,`__LINE__);
        $finish;
    end
end

localparam BASE_LEN = 2**( 16 - $clog2(DSIZE+1) ) // [3,4,5,6,7][8,16,32,64,128]

localparam K36NUM = LENGTH/BASE_LEN + ( (LENGTH%BASE_LEN) != 0 );

logic [2:0]     wcnt;
logic [2:0]     rcnt;

always@(posedge clk,posedge rst)
    if(rst) wcnt    <= '0;
    else  begin
        if(wcnt != 3'b111)
                wcnt    <= wcnt + 1'b1;
        else    wcnt    <= wcnt;
    end

always@(posedge clk,posedge rst)
    if(rst) rcnt    <= '0;
    else  begin
        if(rcnt != 3'b111)
                rcnt    <= rcnt + 1'b1;
        else    rcnt    <= rcnt;
    end

logic   en_wr_en,en_rd_en;

always@(posedge clk,posedge rst)
    if(rst) en_wr_en    <= 1'b0;
    else begin
        if(wcnt == 3'b111)
                en_wr_en    <= 1'b1;
        else    en_wr_en    <= en_wr_en;
    end

always@(posedge clk,posedge rst)
    if(rst) en_rd_en    <= 1'b0;
    else begin
        if(rcnt == 3'b111)
                en_rd_en    <= 1'b1;
        else    en_rd_en    <= en_rd_en;
    end

logic  RST;

assign RST = rst || rst;

logic [K36NUM-1:0]  fifo_wr_en;
logic [K36NUM-1:0]  fifo_rd_en;
logic [DSIZE-1:0]  fifo_wr_data [K36NUM-1:0];
logic [DSIZE-1:0]  fifo_rd_data [K36NUM-1:0];

logic [K36NUM-1:0]  fifo_full;
logic [K36NUM-1:0]  fifo_empty;

/////////////////////////////////////////////////////////////////
// DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
// ===========|===========|============|=======================//
//   37-72    |  "36Kb"   |     512    |         9-bit         //
//   19-36    |  "36Kb"   |    1024    |        10-bit         //
//   19-36    |  "18Kb"   |     512    |         9-bit         //
//   10-18    |  "36Kb"   |    2048    |        11-bit         //
//   10-18    |  "18Kb"   |    1024    |        10-bit         //
//    5-9     |  "36Kb"   |    4096    |        12-bit         //
//    5-9     |  "18Kb"   |    2048    |        11-bit         //
//    1-4     |  "36Kb"   |    8192    |        13-bit         //
//    1-4     |  "18Kb"   |    4096    |        12-bit         //
/////////////////////////////////////////////////////////////////

genvar KK;
generate
for(KK=0;KK<K36NUM;KK++)begin
FIFO_DUALCLOCK_MACRO  #(
    .ALMOST_EMPTY_OFFSET      (9'h010), // Sets the almost empty threshold
    .ALMOST_FULL_OFFSET       (9'h010),  // Sets almost full threshold
    .DATA_WIDTH               (DSIZE    ),   // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
    .DEVICE                   ("7SERIES"),  // Target device: "7SERIES"
    .FIFO_SIZE                ("36Kb"), // Target BRAM: "18Kb" or "36Kb"
    .FIRST_WORD_FALL_THROUGH  ("TRUE") // Sets the FIFO FWFT to "TRUE" or "FALSE"
) FIFO_DUALCLOCK_MACRO_inst (
    .ALMOSTEMPTY    (),     // 1-bit output almost empty
    .ALMOSTFULL     (),     // 1-bit output almost full
    .DO             (fifo_rd_data[KK]   ),                   // Output data, width defined by DATA_WIDTH parameter
    .EMPTY          (fifo_empty[KK]  ),    // 1-bit output empty
    .FULL           (fifo_full[KK]   ),     // 1-bit output full
    .RDCOUNT        (),         // Output read count, width determined by FIFO depth
    .RDERR          (),         // 1-bit output read error
    .WRCOUNT        (),         // Output write count, width determined by FIFO depth
    .WRERR          (),         // 1-bit output write error
    .DI             (fifo_wr_data[KK]    ),                 // Input data, width defined by DATA_WIDTH parameter
    .RDCLK          (clk   ),                                             // 1-bit input read clock
    .RDEN           (fifo_rd_en[KK] && en_rd_en    ),                 // 1-bit input read enable
    .RST            (RST),                                                          // 1-bit input reset
    .WRCLK          (clk   ),                                             // 1-bit input write clock
    .WREN           (fifo_wr_en[KK] && en_wr_en    )                  // 1-bit input write enable
);
end
endgenerate

assign fifo_wr_en[0]    = wr_en;
assign fifo_wr_data[0]  = din;

generate
for(KK=1;KK<K36NUM;KK++)begin
    assign fifo_wr_en[KK]    = !fifo_empty[KK-1] && !fifo_full[KK];
    assign fifo_wr_data[KK]  = fifo_rd_data[KK-1];
    assign fifo_rd_en[KK-1]  = fifo_wr_en[KK];
end
endgenerate

assign fifo_rd_en[K36NUM-1] = rd_en;
assign full    = fifo_full[0];
assign empty   = fifo_empty[K36NUM-1];
assign dout    = fifo_rd_data[K36NUM-1];


endmodule
